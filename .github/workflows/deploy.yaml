name: Deploy Todo App to EKS

on:
  push:
    branches:
      - main
    paths:
      - 'app/**'
      - 'k8s/**'
      - 'terraform/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:  # Permet de lancer manuellement

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.5.0

jobs:
  terraform:
    name: Terraform Apply
    runs-on: ubuntu-latest
    outputs:
      mongodb_uri: ${{ steps.terraform-output.outputs.mongodb_uri }}
      ecr_repo_url: ${{ steps.terraform-output.outputs.ecr_repo_url }}
      eks_cluster_name: ${{ steps.terraform-output.outputs.eks_cluster_name }}
      lb_controller_role_arn: ${{ steps.terraform-output.outputs.lb_controller_role_arn }}
      vpc_id: ${{ steps.terraform-output.outputs.vpc_id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -auto-approve tfplan

      - name: Export Terraform Outputs
        id: terraform-output
        working-directory: ./terraform
        run: |
          echo "mongodb_uri=$(terraform output -raw mongodb_uri)" >> $GITHUB_OUTPUT
          echo "ecr_repo_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT
          echo "eks_cluster_name=$(terraform output -raw eks_cluster_name)" >> $GITHUB_OUTPUT
          echo "lb_controller_role_arn=$(terraform output -raw lb_controller_role_arn)" >> $GITHUB_OUTPUT
          echo "vpc_id=$(terraform output -raw vpc_id)" >> $GITHUB_OUTPUT

  install-lb-controller:
    name: Install AWS Load Balancer Controller
    runs-on: ubuntu-latest
    needs: terraform
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.29.0'

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name ${{ needs.terraform.outputs.eks_cluster_name }} \
            --region ${{ env.AWS_REGION }}

      - name: Check if LB Controller exists
        id: check-lb-controller
        run: |
          if kubectl get deployment -n kube-system aws-load-balancer-controller &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Install AWS Load Balancer Controller
        if: steps.check-lb-controller.outputs.exists == 'false'
        run: |
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          
          helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
            --namespace kube-system \
            --set clusterName=${{ needs.terraform.outputs.eks_cluster_name }} \
            --set serviceAccount.create=true \
            --set serviceAccount.name=aws-load-balancer-controller \
            --set serviceAccount.annotations."eks\.amazonaws\.com/role-arn"=${{ needs.terraform.outputs.lb_controller_role_arn }} \
            --set region=${{ env.AWS_REGION }} \
            --set vpcId=${{ needs.terraform.outputs.vpc_id }} \
            --wait

      - name: Verify LB Controller
        run: |
          kubectl get deployment -n kube-system aws-load-balancer-controller
          kubectl wait --for=condition=available --timeout=300s \
            deployment/aws-load-balancer-controller -n kube-system

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: terraform
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        working-directory: ./app
        run: |
          REGISTRY="${{ needs.terraform.outputs.ecr_repo_url }}"
          REGISTRY="${REGISTRY%%/*}"
          
          docker buildx build \
            --platform linux/amd64 \
            -t ${{ needs.terraform.outputs.ecr_repo_url }}:latest \
            -t ${{ needs.terraform.outputs.ecr_repo_url }}:${{ github.sha }} \
            --push \
            .

  deploy-k8s:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [terraform, install-lb-controller, build-and-push]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.29.0'

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name ${{ needs.terraform.outputs.eks_cluster_name }} \
            --region ${{ env.AWS_REGION }}

      - name: Prepare Kubernetes manifests
        run: |
          sed "s|YOUR_ECR_REPO_URL:latest|${{ needs.terraform.outputs.ecr_repo_url }}:latest|g" \
            k8s/manifest-k8s.yaml > k8s/manifests-deployed.yaml

      - name: Deploy Kubernetes resources
        run: |
          kubectl apply -f k8s/manifests-deployed.yaml

      - name: Wait for namespace
        run: |
          kubectl wait --for=jsonpath='{.status.phase}'=Active \
            namespace/todo-app --timeout=60s

      - name: Create/Update MongoDB Secret
        run: |
          kubectl create secret generic app-secrets \
            --from-literal=MONGODB_URI="${{ needs.terraform.outputs.mongodb_uri }}" \
            --namespace=todo-app \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Restart deployment
        run: |
          kubectl rollout restart deployment/todo-app -n todo-app

      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/todo-app -n todo-app --timeout=5m

      - name: Get deployment status
        run: |
          echo "=== Pods ==="
          kubectl get pods -n todo-app
          echo ""
          echo "=== Services ==="
          kubectl get svc -n todo-app
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n todo-app

  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: deploy-k8s
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.29.0'

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name ${{ needs.terraform.outputs.eks_cluster_name }} \
            --region ${{ env.AWS_REGION }}

      - name: Wait for ALB
        id: wait-alb
        run: |
          echo "Waiting for ALB to be created..."
          for i in {1..60}; do
            ALB_DNS=$(kubectl get ingress todo-app-ingress -n todo-app \
              -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            
            if [ -n "$ALB_DNS" ]; then
              echo "ALB DNS: $ALB_DNS"
              echo "alb_dns=$ALB_DNS" >> $GITHUB_OUTPUT
              break
            fi
            
            echo "Still waiting... ($i/60)"
            sleep 10
          done

      - name: Test health endpoint
        if: steps.wait-alb.outputs.alb_dns != ''
        run: |
          echo "Testing health endpoint..."
          sleep 30  # Wait for ALB to be fully ready
          
          for i in {1..10}; do
            if curl -f -s http://${{ steps.wait-alb.outputs.alb_dns }}/health; then
              echo "Health check passed!"
              break
            fi
            echo "Retry $i/10..."
            sleep 10
          done

      - name: Display application URL
        if: steps.wait-alb.outputs.alb_dns != ''
        run: |
          echo "=================================="
          echo "âœ… Deployment successful!"
          echo "=================================="
          echo ""
          echo "Application URL: http://${{ steps.wait-alb.outputs.alb_dns }}"
          echo "Health check: http://${{ steps.wait-alb.outputs.alb_dns }}/health"
          echo "API endpoint: http://${{ steps.wait-alb.outputs.alb_dns }}/api/todos"
          echo ""